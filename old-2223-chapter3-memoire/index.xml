<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43;::   Gestion mÃ©moire (2022-2023)</title>
    <link>/old-2223-chapter3-memoire/index.html</link>
    <description>Il existe beaucoup de langages dans lequel le concept de propriÃ©tÃ© nâ€™existe pas. Par exemple, en Java, tout le monde et personne nâ€™est propriÃ©taire dâ€™un objet. Lorsque vous crÃ©ez un objet, vous obtenez une rÃ©fÃ©rence que vous pouvez ensuite copier et passer Ã  nâ€™importe quelle autre entitÃ© du programme. Tant quâ€™il existe encore au moins rÃ©fÃ©rence sur lâ€™objet, celui-ci continue dâ€™exister. Ce mÃ©canisme est assurÃ© par le garbage-collector, qui sâ€™occupe de traquer le nombre de rÃ©fÃ©rences de chacun des objets construits.</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <atom:link href="/old-2223-chapter3-memoire/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DurÃ©e de vie</title>
      <link>/old-2223-chapter3-memoire/1-lifespan/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/old-2223-chapter3-memoire/1-lifespan/index.html</guid>
      <description>PortÃ©e dâ€™une variable locale Afin de parler de durÃ©e de vie, nous allons commencer par parler de la portÃ©e de nos variables. Comme vous le savez peut-Ãªtre, la portÃ©e dâ€™une variable dÃ©finit la portion de code dans laquelle le compilateur nous permet de lâ€™utiliser.&#xA;Si on dÃ©finit une variable dans une fonction, la portÃ©e de celle-ci dÃ©marre Ã  sa dÃ©finition et se termine Ã  la fin du bloc dans lequel celle-ci a Ã©tÃ© dÃ©finie.</description>
    </item>
    <item>
      <title>Ownership</title>
      <link>/old-2223-chapter3-memoire/2-ownership/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/old-2223-chapter3-memoire/2-ownership/index.html</guid>
      <description>Ownership On dit quâ€™un objet A est le propriÃ©taire, ou le owner, dâ€™un objet B lorsque la destruction de A entraÃ®ne la destruction de B.&#xA;Dans lâ€™exercice prÃ©cÃ©dent, on peut donc dire que box Ã©tait propriÃ©taire de box._content.&#xA;ConsidÃ©rons un autre exemple :&#xA;std::vector&lt;Box&gt; boxes; boxes.emplace_back(&#34;gift1&#34;); Box&amp; gift2 = boxes.emplace_back(&#34;gift2&#34;); Box gift3 = boxes.emplace_back(&#34;gift3&#34;); Ici, le tableau boxes est le propriÃ©taire des objets boxes[0], boxes[1] et boxes[2]. Il est Ã©galement propriÃ©taire de lâ€™objet gift2, puisquâ€™il sâ€™agit dâ€™une rÃ©fÃ©rence sur boxes[1].</description>
    </item>
    <item>
      <title>Allocation dynamique</title>
      <link>/old-2223-chapter3-memoire/3-allocation/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/old-2223-chapter3-memoire/3-allocation/index.html</guid>
      <description>Nous allons maintenant voir comment il est possible dâ€™allouer de la mÃ©moire simplement, en particulier sans avoir Ã  se soucier des fuites mÃ©moire.&#xA;Allocation dâ€™une primitive Pour crÃ©er un objet sur le tas, nous allons nous servir dâ€™un petit utilitaire appelÃ© std::unique_ptr et de la fonction std::make_unique. Ces deux symboles se trouvent dans le header &lt;memory&gt;.&#xA;Voici la syntaxe permettant dâ€™allouer de la mÃ©moire pour un entier :&#xA;#include &lt;iostream&gt; #include &lt;memory&gt; void fcn() { std::unique_ptr&lt;int&gt; int_on_heap = std::make_unique&lt;int&gt;(3); std::cout &lt;&lt; *int_on_heap &lt;&lt; std::endl; // affiche 3 *int_on_heap = 5; std::cout &lt;&lt; *int_on_heap &lt;&lt; std::endl; // affiche 5 } La classe unique_ptr est donc un symbole que lâ€™on template par le type quâ€™il doit contenir.</description>
    </item>
    <item>
      <title>DÃ©placement</title>
      <link>/old-2223-chapter3-memoire/4-move-sem/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/old-2223-chapter3-memoire/4-move-sem/index.html</guid>
      <description>Nous avons vu prÃ©cÃ©dement que les unique_ptr ne pouvaient pas Ãªtre copiÃ©s. Cependant, le vector a rÃ©ussi Ã  provoquer leur â€œdÃ©placementâ€ en mÃ©moire pour effectuer sa rÃ©allocation.&#xA;Nous allons voir comment faire de mÃªme afin de pouvoir manipuler les unique_ptr avec un peu plus de souplesse.&#xA;Construction sur place Lorsquâ€™une fonction retourne un objet et que celui-ci est utilisÃ© pour initialiser une variable, aucune copie nâ€™a lieu. Lâ€™objet est directement construit Ã  lâ€™adresse mÃ©moire qui lui Ã©tait rÃ©servÃ©e dans le code appelant.</description>
    </item>
    <item>
      <title>Questionnaire !</title>
      <link>/old-2223-chapter3-memoire/test/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/old-2223-chapter3-memoire/test/index.html</guid>
      <description>Câ€™est lâ€™heure du test ! Bon courage ğŸ™‚&#xA;Vous Ãªtes : Votre adresse mail : Votre groupe de TP: Initiaux GR1 (avec Anthony Labarre) Initiaux GR2 (avec Victor Marsault) Apprentis GR3 (avec Henri Derycke) 1. Comment dÃ©finir la pÃ©riode de validitÃ© dâ€™un objet ?&#xA;2. Citez une bonne raison dâ€™allouer de la mÃ©moire via un unique_ptr plutÃ´t que via un pointeur simple (avec new).&#xA;3. Quelle fonction de la librarie standard permet de transfÃ©rer le contenu dâ€™un objet dans un autre ?</description>
    </item>
    <item>
      <title>SynthÃ¨se</title>
      <link>/old-2223-chapter3-memoire/summary/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/old-2223-chapter3-memoire/summary/index.html</guid>
      <description>Ce quâ€™il faut retenir ThÃ©orie La durÃ©e de vie dâ€™un objet sâ€™Ã©tend de sa construction Ã  sa destruction. Lorsque la durÃ©e de vie dâ€™un objet sâ€™achÃ¨ve, il nâ€™est plus valide de lâ€™utiliser. La portÃ©e dâ€™une rÃ©fÃ©rence peut excÃ©der la durÃ©e de vie de lâ€™objet rÃ©fÃ©rencÃ© (=&gt; dangling reference). Un objet A est propriÃ©taire dâ€™un objet B si la destruction de A entraÃ®ne celle de B. Aucune copie nâ€™est faite lorsquâ€™on initialise une variable avec la valeur de retour dâ€™une fonction (mandatory copy-elision) Pratique Un unique_ptr nâ€™est pas copiable.</description>
    </item>
  </channel>
</rss>